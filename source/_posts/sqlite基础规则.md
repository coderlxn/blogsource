---
title: SQLite基础规则
date: 2018-09-25 09:24:38
tags: SQLite
---
##### 数据类型
* SQLite使用一个更普遍的动态类型系统，值的类型与值本身是相关的，而不是与它的容器相关
* SQLite存储类，每个存储在SQLite数据库中的值都属于以下存储类之一：
  * NULL	值是一个NULL值
  * INTEGER		值是一个带符号的整数，根据值的大小存储在1、2、3、4、6、或8字节中
  * REAL	值是一个浮点值，存储为8字节的IEEE浮点数字
  * TEXT	值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储
  * BLOB	值是一个blob数据，完全根据它的输入存储

##### 类型亲和
* SQLite不强制数据类型约束。任何数据都可以插入任何列。你可以向一个整型列中插入任意长度的字符串，向布尔型列中插入浮点数，或者向字符型列中插入日期型值。在 CREATE TABLE 中所指定的数据类型不会限制在该列中插入任何数据。任何列均可接受任意长度的字符串（只有一种情况除外：标志为INTEGER PRIMARY KEY的列只能存储64位整数， 当向这种列中插数据除整数以外的数据时，将会产生错误。）但SQLite确实使用声明的列类型来指示你所期望的格式。所以，例如你向一个整型列中插入字符串时，SQLite会试图将该字符串转换成一个整数。如果可以转换，它将插入该整数；否则，将插入字符串。这是一个特性，而不是一个bug。这种特性被称为类型或列亲和性(type or column affinity).
* 优点：
    1. 提高和其它DBMS的兼容性，让用户就像是在用一般的DBMS一样而使用它，提高了容错能力。
    2. SQLite支持的数据类型只有五种，而其它的大型DBMS支持的数据类型有几十种，那么如果要将其它的数据转换成SQLite下的数据就根本不能实现，所以就将它的数据类型设计为亲和性的，数据类型种类少了系统实现会简单很多，整个系统也就不会太庞大，因为如果有太多的数据类型限制的话，本身系统在实现方面也会困难些。然而，虽然它支持的类型虽然只有五种，可是实际上任何类型都支持了，这就是SQLite数据类型亲和性的巧妙之处。
    3. 在插入数据的时候只要做一些检查和转换即可，实现容易
 * 缺点：
    1. 在对表中数据进行统计方面如果有不一致的数据存在则运算比较混乱，其实也就是放宽政策为的是让更多人去维护。不过它自己是有处理方法的，如果在运算时出现不同类型的数据时就忽略不计等
    2.  还有在数据比较方面也存在同样的问题，不过也有相应的补救措施，自己规定了比较准则：
        1. 一个具有空存储类型的值被认为小于任何值（包括另外一个具有空存储类型的值）
        2. 一个整数值或实数值小于任何文本值和BLOB值。 当一个整数或实数和另一个整数或实数相比较的时候，则按照实际数值来比较。
        3. 一个文本值小于BLOB值。当两个文本值相比较的时候，则用C语言类库中的memcmp()函数来比较。然而，有时候也不是这样的，比如在下面所描述的“用户定义的整理顺序”情况下。
        4. 当两个BLOB文本被比较的时候，结果决定于memcmp()函数。
##### 备份机制
在命令提示符中使用 SQLite .dump 点命令来导出完整的数据库在一个文本文件中
```
$sqlite3 testDB.db .dump > testDB.sql
```
从生成的sql文件恢复
```
$sqlite3 testDB.db < testDB.sql
```